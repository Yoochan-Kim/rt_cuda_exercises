# Stage 02: Vector Addition Validation

## 튜토리얼 목표

- GPU 벡터 덧셈 커널 구현 흐름 이해
- 스레드 구성에 맞는 그리드 크기 계산 복습
- 호스트와 디바이스 간 메모리 전송 절차 점검
- GPU 결과를 CPU 기준값과 비교해 검증하는 패턴 익히기

## 핵심 개념

### CPU에서의 인덱스 기록 복습

Stage 01에서 다루었던 문제를 CPU 관점에서 보면, 단순히 반복문을 돌며 각 위치에 인덱스를 기록하는 작업입니다:

```cpp
for (int i = 0; i < count; ++i) {
    data[i] = i;
}
```

한 번에 하나의 요소만 처리하므로 `count`가 커질수록 실행 시간이 그대로 늘어납니다. 이 루프를 GPU로 옮기면 각 반복을 서로 다른 스레드에게 맡길 수 있어 전체 작업을 병렬로 진행할 수 있습니다.

### Stage 01 방식 다시 보기

Stage 01에서는 **블록 1개, 128개 스레드** 구성으로 각 스레드가 자신의 ID를 그대로 배열 인덱스로 사용했습니다:

```cpp
int idx = threadIdx.x;
deviceData[idx] = idx;
```

스레드와 요소가 일대일 대응되기 때문에 구현이 간단했지만, 하나의 블록에 들어갈 수 있는 스레드의 수는 한계가 있습니다. 따라서 더 큰 입력을 빠르게 처리하려면 여러 블록을 만들어 더 많은 스레드를 활용해야 합니다.

### 멀티 블록 실행 구성 이해

이번 단계부터는 블록 수와 스레드 수를 명시적으로 지정해 여러 블록을 활용해 봅니다. 예를 들어 다음과 같이 정해진 실행 구성을 사용한다고 가정해 보겠습니다:

```cpp
constexpr int kBlocks = 8;
constexpr int kThreads = 256;
vectorAddKernel<<<kBlocks, kThreads>>>(...);
```

이 코드는 총 `kBlocks * kThreads`개의 스레드를 생성하며, 스테이지에서는 요소 수도 동일하게 맞춰 1:1 매핑을 유지합니다. 블록 0에는 스레드 0~255, 블록 1에는 스레드 0~255처럼 블록마다 동일한 스레드 구성이 반복되지만, 각 블록이 담당해야 할 데이터 구간이 다르기 때문에 전역 인덱스를 통해 자신이 처리할 위치를 직접 계산해야 합니다. 이렇게 여러 블록으로 나누면 GPU는 더 많은 스레드를 동시에 스케줄링할 수 있어 병렬성을 극대화할 수 있습니다.

### 전역 인덱스 계산하기

각 스레드는 벡터의 어느 위치를 처리할지 스스로 계산해야 합니다. 여러 블록과 스레드가 동시에 실행되는 환경에서는 다음 공식을 활용합니다:

```cpp
const int idx = blockIdx.x * blockDim.x + threadIdx.x;
```

- `blockIdx.x * blockDim.x`: 현재 블록이 시작하는 전역 오프셋
- `threadIdx.x`: 블록 내부에서의 스레드 위치

Stage 01에서는 `threadIdx.x`만으로도 충분했지만, 블록이 여러 개인 경우에는 블록 ID에 따른 시작 위치를 고려한 전역 인덱스 계산이 필수입니다. 위 공식을 사용하면 스레드마다 고유한 `idx`를 안전하게 계산할 수 있으며, 결과적으로 CPU 반복문에서 `i`를 증가시키던 것과 동일한 효과를 얻습니다.

### 전역 인덱스로 벡터 요소에 접근하기

전역 인덱스를 계산했다면 이제 그 값을 이용해 벡터를 처리할 수 있습니다:

```cpp
int idx = blockIdx.x * blockDim.x + threadIdx.x;
deviceData[idx] = idx;
```
> 스레드 수와 요소 수가 정확히 일치하도록 구성했기 때문에 추가 반복이나 경계 검사가 필요하지 않습니다.

Stage 02 실습에서는 위 전역 인덱스 패턴을 활용해 두 벡터를 더하는 커널을 직접 구현하고, CPU에서 계산한 기준값과 비교해 정확성을 확인합니다.

## 실습

### 목표

두 입력 벡터를 더해 출력 벡터를 채우는 CUDA 커널을 작성합니다. 이번 단계에서 소개한 전역 인덱스 계산을 활용해 각 스레드가 한 요소씩 처리하도록 구현하세요.

### 단계

1. 커널 시그니처에서 입력 포인터, 출력 포인터, 요소 수를 어떻게 사용할지 정리합니다.
2. 전역 인덱스 `int idx = blockIdx.x * blockDim.x + threadIdx.x;`를 계산합니다.
3. 해당 인덱스를 사용해 `c = a + b;` 연산을 수행합니다.
4. 덧셈 결과를 출력 배열에 저장한 뒤 CPU 코드와 비교해 동작을 확인합니다.

### 기대 출력

```
Stage 2 vector add matches reference ✅
```

### 참고

- 실수 연산에서는 부동소수 오차가 있을 수 있으므로 절대 오차 허용값을 활용해 비교합니다.
- 실행 구성과 커널이 맞게 작성되면 GPU 결과와 참조 결과가 동일하게 출력됩니다.
